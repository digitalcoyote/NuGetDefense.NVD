using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using NuGet.Versioning;
using NuGetDefense.Core;
using NugetDefense.NVD.API;
using NVDFeedImporter;

namespace NuGetDefense.NVD;

public class VulnerabilityDataUpdater
{
    
    public static void AddFeedToVulnerabilityData(NVDFeed feed,
        Dictionary<string, Dictionary<string, VulnerabilityEntry>> nvdDict)
    {
        foreach (var feedVuln in feed.CveItems)
        {
            var versionsDict = new Dictionary<string, List<string>>();
            var validNuGetPackage = true;
            foreach (var match in feedVuln.Configurations.Nodes.Where(n => n.CpeMatch != null)
                         .SelectMany(n => n.CpeMatch))
            {
                var cpe = Cpe.Parse(match.Cpe23Uri);
                if (cpe.Part != "a") continue;
                if (!versionsDict.ContainsKey(cpe.Product)) versionsDict.Add(cpe.Product, []);
                if (cpe.ProductVersion is "-" or "*")
                {
                    NuGetVersion start = null;
                    NuGetVersion end = null;
                    var includeStart = false;
                    var includeEnd = false;
                    if (!string.IsNullOrWhiteSpace(match.VersionStartIncluding))
                    {
                        validNuGetPackage = validNuGetPackage &&
                                            NuGetVersion.TryParse(match.VersionStartIncluding, out start);
                        includeStart = true;
                    }

                    if (!string.IsNullOrWhiteSpace(match.VersionEndIncluding))
                    {
                        validNuGetPackage = validNuGetPackage &&
                                            NuGetVersion.TryParse(match.VersionEndIncluding, out end);
                        includeEnd = true;
                    }
                    else if (!string.IsNullOrWhiteSpace(match.VersionEndExcluding))
                    {
                        validNuGetPackage = validNuGetPackage &&
                                            NuGetVersion.TryParse(match.VersionEndExcluding, out end);
                    }

                    if (!validNuGetPackage) continue;
                    var range = new VersionRange(start, includeStart, end, includeEnd);
                    if (NuGetVersion.TryParse(cpe.ProductVersion, out _))

                        versionsDict[cpe.Product].Add(string.IsNullOrWhiteSpace(range.ToString()) ? "*" : range.ToString());
                    if (versionsDict[cpe.Product].Count > 1)
                        versionsDict[cpe.Product] = versionsDict[cpe.Product].Where(s => s != "*").Select(v =>
                        {
                            if (!VersionRange.TryParse(v, out _))
                            {
                                var offset = v.TakeWhile(c => char.IsNumber(c) || c == '.').Count();
                                v = v.Insert(offset, "-");
                            }

                            return v;
                        }).ToList();
                }
                else if (Regex.IsMatch(cpe.Update, @"[^a-zA-Z\d]"))
                {
                    var version = string.IsNullOrWhiteSpace(cpe.Update) || cpe.Update == "*" ? $"[{cpe.ProductVersion}]" : $"[{cpe.ProductVersion}-{cpe.Update}]";

                    //TODO: potentially validate with Regex instead
                    if (!VersionRange.TryParse(version, out _))
                    {
                        var offset = cpe.ProductVersion.TakeWhile(c => char.IsNumber(c) || c == '.').Count();
                        version = cpe.ProductVersion.Insert(offset, "-");
                    }

                    versionsDict[cpe.Product].Add(version);
                }

                var cwe = "";
                if (feedVuln.Cve.Problemtype.ProblemtypeData.Any())
                    if (feedVuln.Cve.Problemtype.ProblemtypeData[0].Description.Any())
                        cwe = feedVuln.Cve.Problemtype.ProblemtypeData[0].Description[0].Value;

                var description = "";
                if (feedVuln.Cve.Description.DescriptionData.Any())
                {
                    var sb = new StringBuilder(feedVuln.Cve.Description.DescriptionData[0].Value);
                    for (var index = 1; index < feedVuln.Cve.Description.DescriptionData.Length; index++) sb.AppendLine(feedVuln.Cve.Description.DescriptionData[index].Value);

                    description = sb.ToString();
                }

                foreach (var (key, _) in versionsDict)
                {
                    var changed = false;
                    foreach (var version in versionsDict[key])
                        if (!VersionRange.TryParse(version, out _))
                        {
                            Console.WriteLine(
                                $"{cpe.Product}: {version} is not parsable as a NuGetVersion String and is not being listed as a version for {feedVuln.Cve.CveDataMeta.Id}");
                            var offset = version.TakeWhile(c => char.IsNumber(c) || c == '.').Count();
                            var insert = version.Insert(offset, "-");
                            changed = true;
                        }

                    if (changed) versionsDict[key] = versionsDict[key].Where(v => VersionRange.TryParse(v, out _)).ToList();
                }

                if (!nvdDict.ContainsKey(cpe.Product))
                    nvdDict.Add(cpe.Product,
                        new());
                if (!nvdDict[cpe.Product].ContainsKey(feedVuln.Cve.CveDataMeta.Id))
                {
                    var specifiedVector = Enum.TryParse<Vulnerability.AccessVectorType>(
                        feedVuln.Impact.BaseMetricV3?.CvssV3?.AttackVector, out var vector);
                    nvdDict[cpe.Product].Add(feedVuln.Cve.CveDataMeta.Id, new()
                        {
                            Versions = versionsDict[cpe.Product].ToArray(),
                            Description = description,
                            Cwe = cwe,
                            Vendor = cpe.Vendor,
                            Score = feedVuln.Impact.BaseMetricV3?.CvssV3?.BaseScore,
                            Vector = specifiedVector ? vector : Vulnerability.AccessVectorType.UNSPECIFIED,
                            References = feedVuln.Cve.References.ReferenceData.Select(r => r.Url.ToString())
                                .ToArray()
                        }
                    );
                }
                else
                {
                    var vuln = nvdDict[cpe.Product][feedVuln.Cve.CveDataMeta.Id];
                    vuln.Versions = vuln.Versions.Union(versionsDict[cpe.Product]).ToArray();
                    nvdDict[cpe.Product][feedVuln.Cve.CveDataMeta.Id] = vuln;
                }
            }
        }

        nvdDict.MakeCorrections();
    }
    
    public static async Task<Dictionary<string, Dictionary<string, VulnerabilityEntry>>> CreateNewVulnDataBin(string vulnDataFile, Client nvdApiClient)
    {
        var options = new CvesRequestOptions
        {
            StartIndex = 0
        };
        var vulnDict = await UpdateVulnerabilityDataFromApi(nvdApiClient, options, new());
        VulnerabilityData.SaveToBinFile(vulnDict, vulnDataFile, TimeSpan.FromMinutes(10));
        return vulnDict;
    }

    public static async Task<Dictionary<string, Dictionary<string, VulnerabilityEntry>>> UpdateVulnerabilityDataFromApi(Client nvdApiClient, CvesRequestOptions options, Dictionary<string, Dictionary<string, VulnerabilityEntry>> vulnDict)
    {
        var startIndex = options.StartIndex;
        var totalResults = 0;
        const int retriesMax = 10;
        var retries = 0;
        
        do
        {
            CveResponse? response = null;

            options.StartIndex = startIndex;

            try
            {
                response = await nvdApiClient.GetCvesAsync(options);
            }
            catch(Exception e)
            {
                // Consider a better way to log this out (pass in a logger?)
                Console.WriteLine($"Exception encountered while retrieving CVEs from the NVD API: {e}");
            }

            if (response?.StatusCode == HttpStatusCode.TooManyRequests)
            {
                Thread.Sleep(TimeSpan.FromSeconds(3));
            }
            else if(response is { IsSuccessStatusCode: true })
            {
                AddFeedToVulnerabilityData(response, vulnDict);
                totalResults = response.TotalResults;
                startIndex += response.ResultsPerPage;
                retries = 0;
            }
            else
            {
                retries++;
            }
            
        } while (startIndex < totalResults && retries <= retriesMax);
        vulnDict.MakeCorrections();
        return vulnDict;
    }

    public static void AddFeedToVulnerabilityData(CveResponse feed,
        Dictionary<string, Dictionary<string, VulnerabilityEntry>> nvdDict)
    {
        foreach (var feedVuln in feed.Vulnerabilities)
        {
            var versionsDict = new Dictionary<string, List<string>>();
            var validNuGetPackage = true;
            foreach (var match in (feedVuln.Cve.Configurations ?? []).Where(c => c.Nodes is { Length: > 0 }).SelectMany(c => c.Nodes).SelectMany(n => n.CpeMatch).Where(m => m.Vulnerable))
            {
                var cpe = Cpe.Parse(match.Criteria);
                if (cpe.Part != "a") continue;
                if (!versionsDict.ContainsKey(cpe.Product)) versionsDict.Add(cpe.Product, []);
                if (cpe.ProductVersion is "-" or "*")
                {
                    NuGetVersion? start = null;
                    NuGetVersion? end = null;
                    var includeStart = false;
                    var includeEnd = false;
                    if (!string.IsNullOrWhiteSpace(match.VersionStartIncluding))
                    {
                        validNuGetPackage = validNuGetPackage &&
                                            NuGetVersion.TryParse(match.VersionStartIncluding, out start);
                        includeStart = true;
                    }

                    if (!string.IsNullOrWhiteSpace(match.VersionEndIncluding))
                    {
                        validNuGetPackage = validNuGetPackage &&
                                            NuGetVersion.TryParse(match.VersionEndIncluding, out end);
                        includeEnd = true;
                    }
                    else if (!string.IsNullOrWhiteSpace(match.VersionEndExcluding))
                    {
                        validNuGetPackage = validNuGetPackage &&
                                            NuGetVersion.TryParse(match.VersionEndExcluding, out end);
                    }

                    if (!validNuGetPackage) continue;
                    var range = new VersionRange(start, includeStart, end, includeEnd);
                    if (NuGetVersion.TryParse(cpe.ProductVersion, out _))

                        versionsDict[cpe.Product].Add(string.IsNullOrWhiteSpace(range.ToString()) ? "*" : range.ToString());
                    if (versionsDict[cpe.Product].Count > 1)
                        versionsDict[cpe.Product] = versionsDict[cpe.Product].Where(s => s != "*").Select(v =>
                        {
                            if (!VersionRange.TryParse(v, out _))
                            {
                                var offset = v.TakeWhile(c => char.IsNumber(c) || c == '.').Count();
                                v = v.Insert(offset, "-");
                            }

                            return v;
                        }).ToList();
                }
                else if (Regex.IsMatch(cpe.Update, @"[^a-zA-Z\d]"))
                {
                    var version = string.IsNullOrWhiteSpace(cpe.Update) || cpe.Update == "*" ? $"[{cpe.ProductVersion}]" : $"[{cpe.ProductVersion}-{cpe.Update}]";

                    //TODO: potentially validate with Regex instead
                    if (!VersionRange.TryParse(version, out _))
                    {
                        var offset = cpe.ProductVersion.TakeWhile(c => char.IsNumber(c) || c == '.').Count();
                        version = cpe.ProductVersion.Insert(offset, "-");
                    }

                    versionsDict[cpe.Product].Add(version);
                }

                var cwe = "";
                if (feedVuln.Cve.Weaknesses != null && feedVuln.Cve.Weaknesses.Any())
                    if ((feedVuln.Cve.Weaknesses[0].Descriptions ?? []).Any())
                        cwe = feedVuln.Cve.Weaknesses[0].Descriptions?[0].Value;

                var description = "";
                if (feedVuln.Cve.Descriptions.Any())
                {
                    var sb = new StringBuilder(feedVuln.Cve.Descriptions[0].Value);
                    for (var index = 1; index < feedVuln.Cve.Descriptions.Length; index++) sb.AppendLine(feedVuln.Cve.Descriptions[index].Value);

                    description = sb.ToString();
                }

                foreach (var (key, _) in versionsDict)
                {
                    var changed = false;
                    foreach (var version in versionsDict[key])
                        if (!VersionRange.TryParse(version, out _))
                        {
                            Console.WriteLine(
                                $"{cpe.Product}: {version} is not parsable as a NuGetVersion String and is not being listed as a version for {feedVuln.Cve.Id}");
                            var offset = version.TakeWhile(c => char.IsNumber(c) || c == '.').Count();
                            var insert = version.Insert(offset, "-");
                            changed = true;
                        }

                    if (changed) versionsDict[key] = versionsDict[key].Where(v => VersionRange.TryParse(v, out _)).ToList();
                }

                if (!nvdDict.ContainsKey(cpe.Product))
                    nvdDict.Add(cpe.Product,
                        new());
                if (!nvdDict[cpe.Product].ContainsKey(feedVuln.Cve.Id))
                {
                    var specifiedVector = Enum.TryParse<Vulnerability.AccessVectorType>(
                        feedVuln.Cve.Metrics?.CvssMetricV3?[0].CvssData?.AttachVector, out var vector);
                    nvdDict[cpe.Product].Add(feedVuln.Cve.Id, new()
                        {
                            Versions = versionsDict[cpe.Product].ToArray(),
                            Description = description,
                            Cwe = cwe,
                            Vendor = cpe.Vendor,
                            Score = feedVuln.Cve.Metrics?.CvssMetricV3?[0].CvssData?.BaseScore,
                            Vector = specifiedVector ? vector : Vulnerability.AccessVectorType.UNSPECIFIED,
                            References = (feedVuln.Cve.References ?? []).Select(r => r.Url?.ToString())
                                .ToArray()
                        }
                    );
                }
                else
                {
                    var vuln = nvdDict[cpe.Product][feedVuln.Cve.Id];
                    vuln.Versions = vuln.Versions.Union(versionsDict[cpe.Product]).ToArray();
                    nvdDict[cpe.Product][feedVuln.Cve.Id] = vuln;
                }
            }
        }

        nvdDict.MakeCorrections();
    }
}